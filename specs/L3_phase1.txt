Phase 1: Initial Implementation (Code Skeleton)
Task
Provide a complete C file that implements the st_nrf5340_i2c operations listed above. You can use information from [RELY], [GUARANTEE], and [SPECIFICATION] as described below. Please output only the resulting file.
Phase 1 is allowed to be a skeleton that compiles and contains the correct data structures and control-flow scaffolding, while leaving detailed semantic rules and error handling to Phase 2.
________________________________________
[RELY]
L1 device management (used for registration)
typedef int32_t st_err_t;
typedef int32_t st_ssize_t;

#define ST_EOK      (0)
#define ST_EINVAL   (-22)
#define ST_ENOSYS   (-38)
#define ST_EIO      (-5)

st_err_t st_device_register(struct st_device *dev, const char *name, uint16_t type, uint16_t flags);
L2 I2C class types
typedef uint8_t  st_uint8_t;
typedef uint16_t st_uint16_t;
typedef uint32_t st_uint32_t;

#define ST_I2C_RD (1u << 0)

struct st_i2c_msg {
    st_uint16_t addr;
    st_uint16_t flags;
    st_uint16_t len;
    st_uint8_t *buf;
};

struct st_device;
struct st_i2c_bus_device;

struct st_i2c_ops {
    st_err_t (*init)(struct st_i2c_bus_device *bus);
    st_err_t (*deinit)(struct st_i2c_bus_device *bus);
    st_ssize_t (*master_xfer)(struct st_i2c_bus_device *bus,
                             struct st_i2c_msg msgs[],
                             st_uint32_t num);
    st_err_t (*control)(struct st_i2c_bus_device *bus, int cmd, void *arg);
};

#define ST_DEVICE_CLASS_I2C (0x0102u)

struct st_i2c_bus_device {
    struct st_device parent;
    const struct st_i2c_ops *i2c_ops;
    void *priv;
};
nRF5340 replayer I2C primitives
The driver may use these primitives:
int  replayer_i2c_write_read(st_uint8_t slave_addr,
                            st_uint8_t reg_num,
                            st_uint8_t *rx_buffer,
                            st_uint8_t bytes_to_read);

int  replayer_i2c_write(st_uint8_t slave_addr,
                        st_uint8_t reg_num,
                        st_uint8_t *tx_buffer,
                        st_uint8_t bytes_to_write);

void replayer_i2c_read(st_uint8_t slave_addr,
                       st_uint8_t *rx_buffer,
                       st_uint8_t bytes_to_read);

void replayer_i2c_init(void);
Notes: - Phase 1 may ignore low-level return codes.
________________________________________
[GUARANTEE]
API Compliance
The implementation must provide the following exact signatures:
st_ssize_t st_nrf5340_i2c_master_xfer(struct st_i2c_bus_device *bus,
                                     struct st_i2c_msg msgs[],
                                     st_uint32_t num);

st_err_t st_nrf5340_i2c_init(struct st_i2c_bus_device *bus);
st_err_t st_nrf5340_i2c_deinit(struct st_i2c_bus_device *bus);
st_err_t st_nrf5340_i2c_control(struct st_i2c_bus_device *bus, int cmd, void *arg);

st_err_t st_nrf5340_i2c_adapter_init(const char *name);
Layering
•	L3 must not define or modify L2 message encoding; it only interprets it.
•	L3 must not directly manage global registry semantics beyond calling L1 registration.
________________________________________
[SPECIFICATION]
Precondition (shared)
For st_nrf5340_i2c_master_xfer(): 1) msgs != NULL 2) num >= 1 3) For all i in [0, num): - if msgs[i].len > 0 then msgs[i].buf != NULL - msgs[i].addr is treated as a 7-bit address in the low bits 4) bus may be unused by the transfer function.
Postcondition (Phase 1)
•	The function returns the number of messages it attempted to process.
•	The control flow must support:
o	a combined write-then-read fast path, and
o	a generic sequential path.
Phase 1 Skeleton System Algorithm
1)	If num == 2 and msgs[0] is write and msgs[1] is read and msgs[0].len > 0, call replayer_i2c_write_read(...) and return 2.
2)	Otherwise iterate over msgs[0..num-1]:
o	if read: call replayer_i2c_read(...)
o	else write:
	if len == 1: call replayer_i2c_write(addr, buf[0], NULL, 0)
	if len > 1: call replayer_i2c_write(addr, buf[0], &buf[1], len-1)
3)	Return num.
Adapter init (Phase 1)
•	st_nrf5340_i2c_adapter_init(name) must:
1)	call replayer_i2c_init();
2)	initialize a static or provided struct st_i2c_bus_device instance;
3)	bind bus->i2c_ops to a static struct st_i2c_ops containing .master_xfer = st_nrf5340_i2c_master_xfer (and optional init/deinit/control);
4)	register the bus device via st_device_register((struct st_device*)bus, name, ST_DEVICE_CLASS_I2C, /*flags*/0).
________________________________________
